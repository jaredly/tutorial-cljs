// Compiled by ClojureScript 1.7.228 {}
goog.provide('tutorial_cljs.text.cljs');
goog.require('cljs.core');
tutorial_cljs.text.cljs.text = ";; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n;; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n;; +++++++++++++++                                              +++++++++++++++\n;;                 An Interactive Introduction to ClojureScript\n;; +++++++++++++++                                              +++++++++++++++\n;; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n;; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n;; Adapted from David Nolen's tutorial for Light Table users\n;; https://github.com/swannodette/lt-cljs-tutorial/blob/master/lt-cljs-tutorial.cljs\n\n;; Using this Tutorial\n;; ============================================================================\n\n;; # Evaluating forms\n;;\n;; You can evaluate forms in this tutorial by putting your cursor at the end of\n;; the form and pressing \"Cmd-Enter\". The output will be displayed to the\n;; right of your cursor. You can dismiss the output view (if it's in your way)\n;; with \"Cmd-Shift-Enter\".\n;;\n;; Try evaluating this:\n\n(+ 1 2) ; <- put your cursor right after the closing ) and press Cmd-Enter\n\n;; ^ You can also put your cursor on the following line and press Cmd-Enter\n\n;; Ok, that was cool, but how about some data that's more complicated?\n\n{:some 10\n :other 20\n :list (range 10)} ; evaluate this, and you'll be able to interact with the result\n\n;; # Documentation + auto-complete\n;;\n;; If you click `range` in that code above, the documentation for the range\n;; function will appear in the bottom-right corner of this page. You can type\n;; into this document, and documentation + auto-complete suggestions will\n;; appear. Press Tab (and Shift-Tab) to cycle through the suggestions.\n;;\n;; Go ahead, put your cursor at the end of `map`, and see what other functions\n;; have `map` in the name.\n\nmap\n\n;; # The REPL\n;;\n;; The right hand pane is a REPL where you can type in clojurescript code and\n;; see the results. It will show you documentation + auto-complete suggestions\n;; as well.\n\n\n;; Basics\n;; ============================================================================\n\n;; Declaring a namespaces\n;; ----------------------------------------------------------------------------\n\n;; ClojureScript supports modularity via namespaces. They allow you to group\n;; logical definitions together.\n\n(ns lt-cljs-tutorial.main\n  (:require [clojure.string :as str]))\n\n;; NOTE: We've evaluated this namespace definition for you already, so if you\n;; type ::hello in the REPL, you'll see `:lt-cljs-tutorial.main/hello'\n\n;; :require is how you can import functionality from a different namespace into\n;; the current one. Here we are requiring `clojure.string` and giving it an\n;; alias. We could write the following:\n\n(clojure.string/blank? \"\")\n\n;; But that's really verbose compared to:\n\n(str/blank? \"\")\n\n\n;; Comments\n;; ----------------------------------------------------------------------------\n\n;; There are three ways to create comments in ClojureScript. The first way is\n;; by preceding a line with a semi-colon, just like the lines you are reading\n;; now.\n\n;; The second way is by preceding a form with `#_`. This causes ClojureScript\n;; to skip the evaluation of only the form immediately following, without\n;; affecting the evaluation of the surrounding forms.\n\n;; Try to reveal the secret message below:\n\n(str \"The secret word is \" #_(str/reverse \"tpircSerujolC\"))\n\n;; Finally, you can also create a comment using the `comment` macro. One common\n;; technique is to use the `comment` macro to include code to be evaluated in a\n;; REPL, but which you do not normally want to be included in the compiled\n;; source.\n\n;; For example, try placing your cursor after the last `)` below and type\n;; Command-ENTER:\n\n(comment\n\n  (str/upper-case \"This is only a test...\")\n\n  )\n\n;; The `comment` macro makes the whole form return `nil`. Now go back and\n;; place your cursor after the middle line, then type Command-ENTER. In this way\n;; you can include code samples or quick tests in-line with the rest of\n;; your code.\n\n\n;; Definitions\n;; ----------------------------------------------------------------------------\n\n;; Once you have a namespace, you can start creating top level definitions in\n;; that namespace.\n\n;; You can define a top level with `def`.\n\n(def x 1)\n\nx\n\n;; You can also refer to top level definitions by fully qualifying them.\n\nlt-cljs-tutorial.main/x\n\n;; This means top levels can never be shadowed by locals and function\n;; parameters.\n\n(let [x 2]\n  lt-cljs-tutorial.main/x)\n\n;; One way to define a function is like this.\n\n(def y (fn [] 1))\n\n(y)\n\n;; Defining functions in ClojureScript is common enough that `defn` sugar is\n;; provided and idiomatic.\n\n(defn z [] 1)\n\n(z)\n\n\n;; Literal data types\n;; ----------------------------------------------------------------------------\n\n;; ClojureScript comes out of the box with the usual useful data literals.\n\n;; Booleans\n\n(def a-boolean true)\n\n;; Strings\n\n(def a-string \"Hello!\")\n\n;; Regular Expressions\n\n(def a-regexp #\"\\d{3}-?\\d{3}-?\\d{4}\")\n\n;; Numbers\n\n(def a-number 1)\n\n\n;; Function literals\n;; ----------------------------------------------------------------------------\n\n;; ClojureScript also supports a shorthand function literal which is useful\n;; You can use the % and %N placeholders to represent function arguments.\n\n;; You should not abuse the function literal notation as it degrades readability\n;; outside of simple cases. It is nice for simple functional cases such as\n;; the following. You could map over a ClojureScript vector like this:\n\n(map (fn [n] (* n 2)) [1 2 3 4 5])\n\n;; Or you can save typing a few characters like this:\n\n(map #(* % 2) [1 2 3 4 5])\n\n\n;; JavaScript data type literals\n;; ----------------------------------------------------------------------------\n\n;; You can construct a JavaScript array with the `array` function.\n\n(def an-array (array 1 2 3))\n\n;; But ClojureScript also supports JavaScript data literals via the `#js`\n;; reader literal.\n\n(def another-array #js [1 2 3])\n\n;; Similarly, you can create simple JavaScript objects with `js-obj`.\n\n(def an-object (js-obj \"foo\" \"bar\"))\n\n;; But again you can save a few characters with `#js`.\n\n(def another-object #js {\"foo\" \"bar\"})\n\n;; It's important to note that `#js` is shallow, the contents of `#js` will be\n;; ClojureScript data unless preceded by `#js`.\n\n;; This is a mutable JavaScript object with an immutable ClojureScript vector\n;; inside.\n\n(def shallow #js {\"foo\" [1 2 3]})\n\n\n;; Constructing a type\n;; ----------------------------------------------------------------------------\n\n;; Of course some JavaScript data types you will want to create with a\n;; constructor.\n\n;; (js/Date.) is equivalent to new Date().\n\n(def a-date (js/Date.))\n\n(def another-date #inst \"2014-01-15\")\n\n;; Note the above returns an `#inst` data literal.\n\n(def another-regexp (js/RegExp. \"\\\\d{3}-?\\\\d{3}-?\\\\d{4}\"))\n\n;; Handy\n\n;; NOTE: js/Foo is how you refer to global JavaScript entities of any kind.\n\njs/Date\n\njs/RegExp\n\njs/requestAnimationFrame\n\n;; If you're curious about other JavaScript interop jump to the bottom of this\n;; tutorial.\n\n\n;; ClojureScript data types\n;; ============================================================================\n\n;; Unless there is a good reason, you should generally write your ClojureScript\n;; programs with ClojureScript data types. They have many advantages over\n;; JavaScript data types - they present a uniform API and they are immutable.\n\n;; Vectors\n;; ----------------------------------------------------------------------------\n\n;; Instead of arrays, ClojureScript programmers use persistent vectors. They are\n;; like arrays - they support efficient random access, efficient update\n;; and efficient addition to the end.\n\n(def a-vector [1 2 3 4 5])\n\n;; We can get the length of a vector in constant time via `count`.\n\n(count a-vector)\n\n;; We can add an element to the end.\n\n(def another-vector (conj a-vector 6))\n\n;; Note this does not mutate the array! `a-vector` will be left\n;; unchanged.\n\na-vector\n\nanother-vector\n\n;; Hallelujah! Here is where some ClojureScript magic\n;; happens. `another-vector` appears to be a completely new vector\n;; compared to `a-vector`. But it is not really so. Internally, the new\n;; vector efficiently shares the `a-vector` structure. In this way, you\n;; get the benefits of immutability without paying in performance.\n\n;; We can access any element in a vector with `nth`. The following\n;; will return the second element.\n\n(nth a-vector 1)\n\n(nth [\"foo\" \"bar\" \"baz\"] 1)\n\n;; Or with `get`...\n\n(get a-vector 0)\n\n;; ...which allows you to return an alternate value when the index is\n;; out-of bounds.\n\n(get a-vector -1 :out-of-bounds)\n(get a-vector (count a-vector) :out-of-bounds)\n\n;; Surprisingly, vectors can be treated as functions. This is actually\n;; a very useful property for associative data structures to have as\n;; we'll see below with sets.\n\n(a-vector 1)\n\n([\"foo\" \"bar\" \"baz\"] 1)\n\n\n;; Maps\n;; ----------------------------------------------------------------------------\n\n;; Along with vectors, maps are the most common data type in ClojureScript.\n;; Map usage is analogous to the usage of Object in JavaScript, but\n;; ClojureScript maps are immutable and considerably more flexible.\n\n;; Let's define a simple map. Note `:foo` is a ClojureScript keyword.\n;; ClojureScript programmers prefer to use keywords for keys instead\n;; of strings. They are more distinguishable from the rest of the\n;; code, more efficient than plain strings, and they can be used in\n;; function position (i.e. first position after the open parens), as\n;; we'll see in a moment.\n\n(def a-map {:foo \"bar\" :baz \"woz\"})\n\n;; We can get the number of key-value pairs in constant time.\n\n(count a-map)\n\n;; We can access a particular value for a key with `get`.\n\n(get a-map :foo)\n\n;; and return an alternative value when the key is not present\n\n(get a-map :bar :not-found)\n\n;; We can add a new key-value pair with `assoc`.\n\n(def another-map (assoc a-map :noz \"goz\"))\n\n;; Again a-map is unchanged! Same magic as before for vectors\n\na-map\n\nanother-map\n\n;; We can remove a key-value pair with `dissoc`.\n\n(dissoc a-map :foo)\n\n;; Again a-map is unchanged!\n\na-map\n\n;; Like vectors, maps can act like functions.\n\n(a-map :foo)\n\n;; However ClojureScript keywords themselves can act like functions and the\n;; following is more idiomatic.\n\n(:foo a-map)\n\n;; We can check if a map contains a key, with `contains?`.\n\n(contains? a-map :foo)\n\n;; We can get all the keys in a map with `keys`.\n\n(keys a-map)\n\n;; And all of the values with `vals`.\n\n(vals a-map)\n\n;; We can put a lot of things in a map, even other maps\n(def a-nested-map {:customer-id 1e6\n                   :preferences {:nickname \"Bob\"\n                                 :avatar \"http://en.gravatar.com/userimage/0/0.jpg\"}\n                   :services {:alerts {:daily true}}})\n\n;; and navigate its keys to get the nested value you're interested in\n\n(get-in a-nested-map [:preferences :nickname])\n(get-in a-nested-map [:services :alerts :daily])\n\n;; or just find a top level key-value pair (i.e. MapEntry) by key\n\n(find a-nested-map :customer-id)\n(find a-nested-map :services)\n\n;; There are many cool ways to create maps.\n\n(zipmap [:foo :bar :baz] [1 2 3])\n\n(hash-map :foo 1 :bar 2 :baz 3)\n\n(apply hash-map [:foo 1 :bar 2 :baz 3])\n\n(into {} [[:foo 1] [:bar 2] [:baz 3]])\n\n;; Unlike JavaScript objects, ClojureScript maps support complex keys.\n\n(def complex-map {[1 2] :one-two [3 4] :three-four})\n\n(get complex-map [3 4])\n\n\n;; Keyword digression\n;; ----------------------------------------------------------------------------\n\n;; Let's take a moment to digress about keywords as they are so ubiquitous\n;; in ClojureScript code.\n\n(identity :foo)\n\n;; If you add an additional preceding colon you'll get a namespaced keyword.\n\n(identity ::foo)\n\n;; What good is this for? It allows you to put data into collections without\n;; fear of namespace clashes without the tedium of manual namespacing them\n;; in your source.\n\n(identity {:user/foo ::foo})\n\n\n;; Sets\n;; ----------------------------------------------------------------------------\n\n;; ClojureScript also supports sets.\n\n(def a-set #{:cat :dog :bird})\n\n;; `:cat` is already in `a-set`, so it will be unchanged.\n\n(conj a-set :cat)\n\n;; But `:zebra` isn't.\n\n(conj a-set :zebra)\n\n;; If you haven't guessed already, `conj` is a \"polymorphic\" function that adds\n;; an item to a collection. This is some of the uniformity we alluded to\n;; earlier.\n\n;; `contains?` works on sets just like it does on maps.\n\n(contains? a-set :cat)\n\n;; Like vectors and maps, sets can also act as functions. If the argument\n;; exists in the set it will be returned, otherwise the set will return nil.\n\n(#{:cat :dog :bird} :cat)\n\n;; This is powerful when combined with conditionals.\n\n(defn check [x]\n  (if (#{:cat :dog :bird} x)\n    :valid\n    :invalid))\n\n(check :cat)\n(check :zebra)\n\n\n;; Lists\n;; ----------------------------------------------------------------------------\n\n;; A less common ClojureScript data structure is lists. This may be\n;; surprising as ClojureScript is a Lisp, but maps, vectors and sets\n;; are the 'go-to' data structures for most applications. Still, lists are sometimes\n;; useful\u2014especially when dealing with code (i.e. code is data).\n\n(def a-list '(:foo :bar :baz))\n\n;; `conj` is \"polymorphic\" on lists as well, and it's smart enough to\n;; add the new item in the most efficient way on the basis of the\n;; collection type.\n(conj a-list :front)\n\n;; and lists are immutable as well\n\na-list\n\n;; You can get the first element of a list\n\n(first a-list)\n\n;; or the tail of a list\n\n(rest a-list)\n\n;; which allows you to easly verify how ClojureScript shares data\n;; structure instead of inefficiently copying data for supporting\n;; immutability.\n\n(def another-list (conj a-list :front))\n\nanother-list\n\na-list\n\n(identical? (rest another-list) a-list)\n\n;; `identical?` checks whether two things are represented by the same\n;; thing in memory.\n\n\n;; Equality\n;; ============================================================================\n\n;; ClojureScript has a much simpler notion of equality than what is present\n;; in JavaScript. In ClojureScript equality is always deep equality.\n\n(= {:one 1 :two \"2\"} {:one 1 :two \"2\"})\n\n;; Maps are not ordered.\n\n(= {:one 1 :two \"2\"} {:two \"2\" :one 1})\n\n;; For sequential collections, equality just works.\n\n(= [1 2 3] '(1 2 3))\n\n;; Again, it is possible to check whether two things are represented\n;; by the same thing in memory with `identical?`.\n\n(def my-vec [1 2 3])\n(def your-vec [1 2 3])\n\n(identical? my-vec your-vec)\n\n\n;; Control\n;; ============================================================================\n\n;; In order to write useful programs, we need to be able to express\n;; control flow. ClojureScript provides the usual control constructs,\n;; however truth-y and false-y values are not the same as in\n;; JavaScript so it's worth reviewing.\n\n;; if\n;; ----------------------------------------------------------------------------\n\n;; 0 is not a false-y value.\n\n(if 0\n  \"Zero is not false-y\"\n  \"Yuck\")\n\n;; Nor is the empty string.\n\n(if \"\"\n  \"An empty string is not false-y\"\n  \"Yuck\")\n\n;; the empty vector\n\n(if []\n  \"An empty vector is not false-y\"\n  \"Yuck\")\n\n;; the empty list\n\n(if ()\n  \"An empty list is not false-y\"\n  \"Yuck\")\n\n;; the empty map\n\n(if {}\n  \"An empty map is not false-y\"\n  \"Yuck\")\n\n;; the empty set\n\n(if #{}\n  \"An empty set is not false-y\"\n  \"Yuck\")\n\n;; and even the empty regexp\n\n(if #\"\"\n  \"An empty regexp is not false-y\"\n  \"Yuck\")\n\n;; The only false-y values in ClojureScript are `nil` and `false`. `undefined`\n;; is not really a valid ClojureScript value and is generally coerced to `nil`.\n\n\n;; cond\n;; ----------------------------------------------------------------------------\n\n;; Nesting `if` tends to be noisy and hard to read so ClojureScript\n;; provides a `cond` macro to deal with this.\n\n(cond\n  nil \"Not going to return this\"\n  false \"Nope not going to return this either\"\n  :else \"Default case\")\n\n\n;; loop/recur\n;; ----------------------------------------------------------------------------\n\n;; The most primitive looping construct in ClojureScript is `loop`/`recur`.\n;; Like `let`, `loop` establishes bindings and allows you to set their initial values.\n;; Like `let`, you may have a sequence of forms for the body. In tail\n;; positions, you may write a `recur` statement that will set the bindings for\n;; the next iteration of the `loop`. Using `loop`/`recur` is usually considered bad\n;; style if a reasonable functional solution via `map`/`filter`/`reduce` or a list\n;; comprehension is possible.\n\n;; While you might write this in JavaScript:\n;;\n;; var ret = [];\n;; for(var i = 0; i < 10; i++) ret.push(i)\n;;\n;; In ClojureScript you would write `loop`/`recur` like so:\n\n(loop [i 0 ret []]\n  (if (< i 10)\n    (recur (inc i) (conj ret i))\n    ret))\n\n;; Again avoid `loop`/`recur` unless you really need it. The loop above would\n;; be better expressed as the following:\n\n(into [] (range 10))\n\n\n;; Moar functions\n;; ============================================================================\n\n;; Functions are the essence of any significant ClojureScript program, so\n;; we will dive into features that are unique to ClojureScript functions that\n;; might be unfamiliar.\n\n;; Here is a simple function that takes two arguments and adds them.\n\n(defn foo1 [a b]\n  (+ a b))\n\n(foo1 1 2)\n\n;; Functions can have multiple arities.\n\n(defn foo2\n  ([a b] (+ a b))\n  ([a b c] (* a b c)))\n\n(foo2 3 4)\n(foo2 3 4 5)\n\n;; Multiple arities can be used to supply default values.\n\n(defn defaults\n  ([x] (defaults x :default))\n  ([x y] [x y]))\n\n(defaults :explicit)\n(defaults :explicit1 :explicit2)\n\n;; Functions support rest arguments.\n\n(defn foo3 [a b & d]\n  [a b d])\n\n(foo3 1 2)\n(foo3 1 2 3 4)\n\n;; You can apply functions.\n\n(apply + [1 2 3 4 5])\n\n\n;; multimethods\n;; ----------------------------------------------------------------------------\n\n;; Often when you need some polymorphism, and performance isn't an issue,\n;; multimethods will suffice. Multimethods are functions that allow open\n;; extension, but instead of limiting dispatch to type, dispatch is controlled\n;; by whatever value the dispatch fn originally supplied to `defmulti` returns.\n\n;; Here is the simplest multimethod you can write. It simply dispatches on\n;; the value received.\n\n(defmulti simple-multi identity)\n\n;; Now we can define methods for particular values.\n\n(defmethod simple-multi 1\n  [value] \"Dispatched on 1\")\n\n(simple-multi 1)\n\n(defmethod simple-multi \"foo\"\n  [value] \"Dispatched on foo\")\n\n(simple-multi \"foo\")\n\n;; However we haven't defined a case for \"bar\"\n; (Highlight and evaluate the `simple-multi` form below)\n(comment\n  (simple-multi \"bar\")\n  )\n\n\n;; Here is a function that takes a list. It dispatches on the first element\n;; of the list!\n;; Note that this example uses destructuring, which is covered later.\n\n(defmulti parse (fn [[f & r :as form]] f))\n\n(defmethod parse 'if\n  [form] {:op :if})\n\n(defmethod parse 'let\n  [form] {:op :let})\n\n(parse '(if a b c))\n(parse '(let [x 1] x))\n\n\n;; Scoping\n;; ============================================================================\n\n;; Unlike JavaScript, there is no hoisting in ClojureScript. ClojureScript\n;; has lexical scoping.\n\n(def some-x 1)\n\n(let [some-x 2]\n  some-x)\n\nsome-x\n\n;; Closures\n;; ----------------------------------------------------------------------------\n\n;; Could a language with such a name miss closures? Surely it can't. You\n;; may be already familiar with them in JavaScript, even if it's a\n;; variable scoped language.\n\n(let [a 1e3]\n  (defn foo []\n    (* a a))\n  (defn bar []\n    (+ (foo) a)))\n\n;; Above we defined `foo` and `bar` functions inside the scope of a\n;; `let` form and they both know about `a` (i.e. they close over `a`)\n;; Note, even if defined inside a `let`, `foo` and `bar` are available\n;; in the outer scope. This is because all `def` expressions are always\n;; top level. See the footnote at the end of this section.\n\n\n(foo)\n(bar)\n\n;; And Nobody else.\n\n(comment\n  (defn baz []\n    (type a))\n  (baz)\n  )\n\n;; That's why some people say that closures are the poor man's objects.\n;; They encapsulate the information as well.\n\n;; But in ClojureScript, functions' parameters and let bindings' locals\n;; are not mutable! That goes for loop locals, too!\n\n(let [fns (loop [i 0 ret []]\n            (if (< i 10)\n              (recur (inc i) (conj ret (fn [] i)))\n              ret))]\n  (map #(%) fns))\n\n;; In JavaScript you would see a list of ten 9s. In ClojureScript we\n;; see the expected numbers from 0 to 9.\n\n;; FOOTNOTE:\n;;\n;; `def` expressions (including `defn`) are always top level. People familiar\n;; with Scheme or other Lisps often mistakenly write the following in Clojure:\n\n(defn not-scheme []\n  (defn no-no-no []))\n\n;; This is almost always incorrect. If you need to write a local function just\n;; do it with a let binding.\n\n(defn outer-fn []\n  (let [inner-fn (fn [])]))\n\n\n;; Destructuring\n;; ============================================================================\n\n;; In any serious ClojureScript program, there will be significant amounts of\n;; data manipulation. Again, we will see that ClojureScript's uniformity\n;; pays off.\n\n;; In ClojureScript anywhere bindings are allowed (like `let` or function\n;; parameters), destructuring is allowed. This is similar to the destructuring\n;; proposed for ES6, but the system provided in ClojureScript benefits from\n;; all the collections supporting uniform access.\n\n\n;; Sequence destructuring\n;; ----------------------------------------------------------------------------\n\n;; Destructuring sequential types is particularly useful.\n\n(let [[f & r] '(1 2 3)]\n  f)\n\n(let [[f & r] '(1 2 3)]\n  r)\n\n(let [[r g b] [255 255 150]]\n  g)\n\n;; _ is just a convention for saying that you are not interested in the\n;; item at the corresponding position. It has no other special meaning.\n;; Here we're only interested in the third local variable named `b`.\n\n(let [[_ _ b] [255 255 150]]\n  b)\n\n;; destructuring function arguments works just as well. Here we are\n;; only interested in the second argument `g`.\n\n(defn green [[_ g _]] g)\n\n(green [255 255 150])\n\n\n;; Map destructuring\n;; ----------------------------------------------------------------------------\n\n;; Map destructuring is also useful. Here we destructure the value for the\n;; `:foo` key and bind it to a local `f`, and the value for `:baz` key\n;; and bind it to a local `b`.\n\n(let [{f :foo b :baz} {:foo \"bar\" :baz \"woz\"}]\n  [f b])\n\n;; If we don't want to rename, we can just use `:keys`.\n\n(let [{:keys [first last]} {:first \"Bob\" :last \"Smith\"}]\n  [first last])\n\n; We can also destructure a nested map\n\n(let [{:keys [first last] {:keys [addr1 addr2]} :address} {:first \"Bob\" :last \"Smith\" :address {:addr1 \"123\" :addr2 \"Main street\"}}]\n  [first last addr1 addr2])\n\n; Similar to :keys for keyword, :strs and :syms directives are available for matching string and symbol :keys\n\n(let [{:strs [first last]} {\"first\" \"Bob\" \"last\" \"Smith\"}]\n  [first last])\n\n(let [{:syms [first last]} {'first \"Bob\" 'last \"Smith\"}]\n  [first last])\n\n;; The above map destructuring form is very useful when you need to\n;; define a function with optional, non positional and defaulted\n;; arguments.\n\n(defn magic [& {:keys [k g h]\n                :or {k 1\n                     g 2\n                     h 3}}]\n  (hash-map :k k\n            :g g\n            :h h))\n\n(magic)\n(magic :k 10)\n(magic :g 100)\n(magic :h 1000)\n(magic :k 10 :g 100 :h 1000)\n(magic :h 1000 :k 10 :g 100)\n\n;; Sequences\n;; ============================================================================\n\n;; We said that ClojureScript data structures are to be preferred as they\n;; provide a uniform interface. All ClojureScript collections satisfy\n;; the ISeqable protocol, which means iteration is uniform\n;; (i.e. polymorphic) for all collection types.\n\n\n;; Map / Filter / Reduce\n;; ----------------------------------------------------------------------------\n\n;; ClojureScript supports the same bells and whistles out of the box that you may\n;; be familiar with from other functional programming languages or JavaScript\n;; libraries such as Underscore.js\n\n(map inc [0 1 2 3 4 5 6 7 8 9])\n\n(filter even? (range 10))\n\n(remove odd? (range 10))\n\n;; ClojureScript's `map` and `filter` operations are lazy. You can stack up\n;; operations without getting too concerned about multiple traversals.\n\n(map #(* % %) (filter even? (range 20)))\n\n(reduce + (range 100))\n\n\n;; List comprehensions\n;; ----------------------------------------------------------------------------\n\n;; ClojureScript supports the list comprehensions you might know from various\n;; languages. List comprehensions are sometimes more natural or more readable\n;; than a chain of `map` and `filter` operations.\n\n(for [x (range 1 10)\n      y (range 1 10)]\n  [x y])\n\n(for [x (range 1 10)\n      y (range 1 10)\n      :when (and (zero? (rem x y))\n                 (even? (quot x y)))]\n  [x y])\n\n(for [x (range 1 10)\n      y (range 1 10)\n      :let [prod (* x y)]]\n  [x y prod])\n\n\n;; Seqable collections\n;; ----------------------------------------------------------------------------\n\n;; Most ClojureScript collections can be coerced into sequences.\n\n(seq {:foo \"bar\" :baz \"woz\"})\n(seq #{:cat :dog :bird})\n(seq [1 2 3 4 5])\n(seq '(1 2 3 4 5))\n\n;; Many ClojureScript functions will call `seq` on their arguments in order to\n;; provide the expected behavior. The following demonstrates that you can\n;; uniformly iterate over all the ClojureScript collections!\n\n(first {:foo \"bar\" :baz \"woz\"})\n(rest {:foo \"bar\" :baz \"woz\"})\n\n(first #{:cat :dog :bird})\n(rest #{:cat :dog :bird})\n\n(first [1 2 3 4 5])\n(rest [1 2 3 4 5])\n\n(first '(1 2 3 4 5))\n(rest '(1 2 3 4 5))\n\n\n;; Metadata\n;; ============================================================================\n\n;; All of the ClojureScript standard collections support metadata. Metadata\n;; is a useful way to annotate data without affecting equality. The\n;; ClojureScript compiler uses this language feature to great effect.\n\n;; You can add metadata to a ClojureScript collection with `with-meta`. The\n;; metadata must be a map.\n\n(def plain-data [0 1 2 3 4 5 6 7 8 9])\n\n(def decorated-data (with-meta plain-data {:url \"http://lighttable.com\"}))\n\n;; Metadata has no effect on equality.\n\n(= plain-data decorated-data)\n\n;; You can access metadata with `meta`.\n\n(meta decorated-data)\n\n\n;; Error Handling\n;; ============================================================================\n\n;; Error handling in ClojureScript is relatively straightforward and more or\n;; less similar to what is offered in JavaScript.\n\n;; You can construct an error like this.\n\n(js/Error. \"Oops\")\n\n;; You can throw an error like this.\n;; (Highlight and evaluate the `throw` form below)\n\n(comment\n  (throw (js/Error. \"Oops\"))\n  )\n\n;; You can catch an error like this.\n\n(try\n  (throw (js/Error. \"Oops\"))\n  (catch js/Error e\n    e))\n\n;; JavaScript unfortunately allows you to throw anything. You can handle\n;; this in ClojureScript with the following.\n\n(try\n  (throw (js/Error. \"Oops\"))\n  (catch :default e\n    e))\n\n;; Catches are optional. You can also use multiple forms to handle different types of errors.\n\n(try\n  (throw (js/Error. \"Oops\"))\n  (catch js/Error e\n    e)\n  (catch Error e\n    e)\n  (finally\n     \"Cleanup here\"))\n\n\n;; Mutation\n;; ============================================================================\n\n;; Atoms\n;; ----------------------------------------------------------------------------\n\n;; A little bit of mutability goes a long way. ClojureScript does not offer\n;; any traditional mutable data structures, however it does support identities\n;; that can evolve over time via `atom`.\n\n(def x (atom 1))\n\n;; You can dereference the value of an atom with `@`.\n\n@x\n\n;; This is equivalent to calling `deref`.\n\n(deref x)\n\n;; If you want to change the value of an atom you can use `reset!` which returns\n;; the new value. It's idiomatic to add the bang char `!` at the end of function\n;; names mutating objects.\n\n(reset! x 2)\n\nx\n\n@x\n\n;; swap!\n;; ------------------------------------------------------------------------------\n\n;; If you want to change the value of an atom on the basis of its current value,\n;; you can use `swap!`. In its simplest form, `swap!` accepts as a first argument\n;; the atom itself and as a second argument an updating function of one argument\n;; which will be instantiated with the current value of the atom. `swap!` returns\n;; the new value of the atom.\n\n(swap! x inc)\n\nx\n\n@x\n\n;; If your updating function needs extra arguments to calculate the new value, you\n;; have to pass them as extra arguments to `swap!` after the updating function\n;; itself.\n\n(swap! x (fn [old extra-arg]\n           (+ old extra-arg)) 39)\n\nx\n\n@x\n\n;; As usual when anonymous functions are simple enough, it's idiomatic to use\n;; the condensed form.\n\n(swap! x #(- %1 %2) 42)\n\nx\n\n@x\n\n;; Note that the updating function has to be free of side-effects because a\n;; waiting writer could call it more than once in a spin loop.\n\n\n;; set!\n;; ----------------------------------------------------------------------------\n\n;; Sometimes you need to mutate existing JavaScript objects. For this you\n;; have `set!`.\n\n(def c (.createElement js/document \"canvas\"))\n(def ctxt (.getContext c \"2d\"))\n\n;; We can use property access with `set!` to change the fill color of a\n;; a canvas rendering context.\n\n(set! (.-fillColor ctxt) \"#ffffff\")\n\n\n;; The ClojureScript Standard Library\n;; ============================================================================\n\n;; The ClojureScript standard library largely mirrors the Clojure standard\n;; library with the exception of functionality that assumes a multithreaded\n;; environment, first class namespaces, and Java numerics.\n\n;; Here are some highlights and patterns that newcomers to ClojureScript might\n;; find useful. Remember you can type Control-Shift-D at anytime to bring up\n;; the documentation panel to see what any of these function do.\n\n(apply str (interpose \", \" [\"Bob\" \"Mary\" \"George\"]))\n\n((juxt :first :last) {:first \"Bob\" :last \"Smith\"})\n\n(def people [{:first \"John\" :last \"McCarthy\"}\n             {:first \"Alan\" :last \"Kay\"}\n             {:first \"Joseph\" :last \"Licklider\"}\n             {:first \"Robin\" :last \"Milner\"}])\n\n(map :first people)\n\n(take 5 (repeat \"red\"))\n\n(take 5 (repeat \"blue\"))\n\n(take 5 (interleave (repeat \"red\") (repeat \"blue\")))\n\n(take 10 (cycle [\"red\" \"white\" \"blue\"]))\n\n(partition 2 [:a 1 :b 2 :c 3 :d 4 :e 5])\n\n(partition 2 1 [:a 1 :b 2 :c 3 :d 4 :e 5])\n\n(take-while #(< % 5) (range 10))\n\n(drop-while #(< % 5) (range 10))\n\n\n;; Protocols\n;; ============================================================================\n\n;; The ClojureScript language is constructed on a rich set of protocols. The\n;; same uniformity provided by ClojureScript collections can be extended to\n;; your own types or even types that you do not control!\n\n;; A lot of the uniform power we saw early was because the ClojureScript\n;; collections are implemented in terms of protocols. Collections can be\n;; coerced into sequences because they implement ISeqable. You can use `get`\n;; on vectors and maps because they implement ILookup.\n\n(get {:foo \"bar\"} :foo)\n(get [:cat :bird :dog] 1)\n\n;; Map destructuring actually desugars into `get` calls. That means if you extend\n;; your type to ILookup it will also support map destructuring!\n\n\n;; extend-type\n;; ----------------------------------------------------------------------------\n\n;; ClojureScript supports custom extension to types that avoid many of the\n;; pitfalls that you encounter in other languages. For example imagine we have\n;; some awesome polymorphic functionality in mind.\n\n(defprotocol MyProtocol (awesome [this]))\n\n;; It's idiomatic to name the first argument of a protocol's functions\n;; as `this` which reminds you that it is the argument used by\n;; ClojureScript to dispatch the right function implementation on the\n;; basis of the type of the value of `this`\n\n;; Now imagine we want JavaScript strings to participate. We can do this\n;; simply.\n\n(extend-type string\n  MyProtocol\n  (awesome [this] (vector this \"Totally awesome!\")))\n\n(awesome \"Is this awesome?\")\n\n\n;; extend-protocol\n;; ----------------------------------------------------------------------------\n\n;; Sometimes you want to extend several types to a protocol at once. You can\n;; use extend-protocol for this. extend-protocol simply desugars into multiple\n;; extend-type forms.\n\n;; As said while learning about `let` special form, when we're not\n;; interested in the value of an argument it's idiomatic to use the\n;; underscore as a placeholder like above.\n\n(extend-protocol MyProtocol\n  js/Date\n  (awesome [_] \"Having an awesome time!\")\n  number\n  (awesome [_] \"I'm an awesome number!\"))\n\n(awesome #inst \"2014\")\n(awesome 5)\n\n\n;; reify\n;; ----------------------------------------------------------------------------\n\n;; Sometimes it's useful to make an anonymous type which implements various\n;; protocols.\n\n;; For example say we want a JavaScript object to support ILookup. Now we don't\n;; want to blindly `extend-type object`, that would pollute the behavior of plain\n;; JavaScript objects for everyone.\n\n;; Instead we can provide a helper function that takes an object and returns\n;; something that provides this functionality.\n\n(defn ->lookup [obj]\n  (reify\n    ILookup\n    (-lookup [this k]\n      (-lookup this k nil))\n    (-lookup [this k not-found]\n      (let [k (name k)]\n        (if (.hasOwnProperty obj k)\n          (aget obj k)\n          not-found)))))\n\n;; We can then selectively make JavaScript objects work with `get`.\n\n(get (->lookup #js {\"foo\" \"bar\"}) :foo)\n\n;; But this also means we get destructuring on JavaScript objects.\n\n(def some-object #js {\"foo\" \"bar\" \"baz\" \"woz\"})\n\n(let [{:keys [foo baz]} (->lookup some-object)]\n  [foo baz])\n\n\n;; specify\n;; ----------------------------------------------------------------------------\n\n;; TODO fill this out\n\n;; Macros\n;; ============================================================================\n\n\n;; Types & Records\n;; ============================================================================\n\n;; deftype\n;; ----------------------------------------------------------------------------\n\n;; Sometimes a map will simply not suffice, in these cases you will want to\n;; make your own custom type.\n\n(deftype Foo [a b])\n\n;; It's idiomatic to use CamelCase to name a `deftype`. You can instantiate a\n;; deftype instance using the same constructor pattern we've already discussed.\n\n(Foo. 1 2)\n\n;; You can access properties of a deftype instance using property access\n;; syntax.\n\n(.-a (Foo. 1 2))\n\n;; You can implement protocol methods on a deftype. Note that the first\n;; argument to any deftype or defrecord method is the instance itself.\n;; The dash in `-count` has no special meaning. It's just a convention for\n;; the core ClojureScript protocols. You need not adopt it.\n\n(deftype Foo [a b]\n  ICounted\n  (-count [this] 2))\n\n(count (Foo. 1 2))\n\n;; Sometimes it's useful to implement methods directly on the deftype.\n\n(deftype Foo [a b]\n  Object\n  (toString [this] (str a \", \" b)))\n\n(.toString (Foo. 1 2))\n\n;; deftype fields are immutable unless specified. The following will not compile.\n;; (To prove it to yourself, highlight and evaluate the `deftype` form below.)\n\n(comment\n\n  (deftype Foo [a ^:mutable b]\n    Object\n    (setA [this val] (set! a val)))\n\n  )\n\n;; The following will compile.\n\n(deftype Foo [a ^:mutable b]\n  Object\n  (setB [this val] (set! b val)))\n\n\n;; defrecord\n;; ----------------------------------------------------------------------------\n\n;; `deftype` doesn't provide much out of the box. Often what you want to do is\n;; have a domain object that acts more or less like a map. This is what\n;; `defrecord` is for.\n\n;; Like `deftype`, it's idiomatic to use CamelCase to name a `defrecord`.\n\n(defrecord Person [first last])\n\n;; You can construct an instance in the usual way.\n\n(Person. \"Bob\" \"Smith\")\n\n;; Or you can use the provided constructors.\n\n(->Person \"Bob\" \"Smith\")\n\n(map->Person {:first \"Bob\" :last \"Smith\"})\n\n;; It's considered idiomatic (and recommended) to define a factory function\n;; which returns the created instance of a defrecord/deftype. It's idiomatic to use\n;; dash-case for factories names.\n\n(defn person [first last]\n  (->Person first last))\n\n;; records work like maps\n\n(seq (person \"Bob\" \"Smith\"))\n\n(:first (person \"Bob\" \"Smith\"))\n\n(keys (person \"Bob\" \"Smith\"))\n\n(vals (person \"Bob\" \"Smith\"))\n\n;; both deftype and defrecord are open to dynamic extensions (i.e. open class)\n\n(keys (assoc (person \"Bob\" \"Smith\") :age 18))\n\n\n;; Records & Protocols\n;; ----------------------------------------------------------------------------\n\n;; You can extend a defrecord to satisfy a protocol as you do with deftype.\n\n(extend-type Person\n  MyProtocol\n  (awesome [this]\n    (str (:last this) \", \" (:first this))))\n\n(awesome (person \"Bob\" \"Smith\"))\n\n(satisfies? MyProtocol (person \"Bob\" \"Smith\"))\n\n;; Or you can extend a protocol on a defrecord.\n\n(extend-protocol MyProtocol\n  Person\n  (awesome [this]\n    (str (:last this) \", \" (:first this))))\n\n(awesome (person \"Bob\" \"Smith\"))\n\n(satisfies? MyProtocol (person \"Bob\" \"Smith\"))\n\n;; If you need a more sophisticated form of polymorphism consider multimethods.\n\n;; If you mix types/records with protocols you are modeling your problem with an\n;; object oriented approach, which is sometimes useful.\n\n;; Note ClojureScript does not offer a direct form of inheritance. Instead,\n;; reuse/extension by composition is encouraged. It's best to avoid\n;; deftype/defrecord and model your problem with plain maps. You can easily\n;; switch to records later on down the line.\n\n(defrecord Contact [person email])\n\n;; Even if it's not required, remember to define a factory function to create\n;; instances of the new Contact record type by internally calling the factory\n;; function for the Person record type.\n\n(defn contact [first last email]\n  (->Contact (person first last) email))\n\n(contact \"Bob\" \"Smith\" \"bob.smith@acme.com\")\n\n;; And extend the protocol on defrecord as well.\n\n(extend-protocol MyProtocol\n  Contact\n  (awesome [this]\n    (str (awesome (:person this)) \", \" (:email this))))\n\n(awesome (contact \"Bob\" \"Smith\" \"bob.smith@acme.com\"))\n\n;; To change the value of a nested key you use 'assoc-in', like with maps.\n\n(assoc-in (contact \"Bob\" \"Smith\" \"bob.smith@acme.com\")\n          [:person :first] \"Robert\")\n\n;; If you need to use the previous value of a nested field for calculating the\n;; new one, you can use 'update-in', like with maps.\n\n(update-in (contact \"Bob\" \"Smith\" \"bob.smith@acme.com\")\n           [:person :first] #(str/replace %1 #\"Bob\" %2) \"Robert\")\n\n;; As said, the main difference with the majority of OO languages is that your\n;; instances of deftypes/defrecords are immutable.\n\n(def bob (contact \"Bob\" \"Smith\" \"bob.smith@acme.com\"))\n\n(update-in bob [:person :first] #(str/replace %1 #\"Bob\" %2) \"Robert\")\n\n(get-in bob [:person :first])\n\n\n;; JavaScript Interop\n;; ============================================================================\n\n;; Property Access\n;; ----------------------------------------------------------------------------\n\n(def a-date (js/Date.))\n\n;; You can access properties with the `.-` property access syntax.\n\n(.-getSeconds a-date)\n\n\n;; Method Calls\n;; ----------------------------------------------------------------------------\n\n;; Methods can be invoked with the `.` syntax.\n\n(.getSeconds a-date)\n\n;; The above desugars into the following.\n\n(. a-date (getSeconds))\n\n;; For example, you can write a `console.log` call like so.\n\n(. js/console (log \"Interop!\"))\n\n\n;; Primitive Array Operations\n;; ----------------------------------------------------------------------------\n\n;; When writing performance sensitive code, sometimes dealing with mutable\n;; arrays is unavoidable. ClojureScript provides a variety of functions for\n;; creating and manipulating JavaScript arrays.\n\n;; You can make an array of specific size with `make-array`\n\n(make-array 32)\n\n;; You can access an element of an array with `aget`.\n\n(aget #js [\"one\" \"two\" \"three\"] 1)\n\n;; You can access nested arrays with `aget`.\n\n(aget #js [#js [\"one\" \"two\" \"three\"]] 0 1)\n\n;; You can set the contents of an array with aset.\n\n(def yucky-stuff #js [1 2 3])\n\n(aset yucky-stuff 1 4)\n\nyucky-stuff\n  ";

//# sourceMappingURL=cljs.js.map