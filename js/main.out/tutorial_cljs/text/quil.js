// Compiled by ClojureScript 1.7.228 {}
goog.provide('tutorial_cljs.text.quil');
goog.require('cljs.core');
tutorial_cljs.text.quil.text = ";; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n;; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n;; +++++++++++++++                                             ++++++++++++++++\n;;                     An Interactive Introduction to Quil\n;; +++++++++++++++                                             ++++++++++++++++\n;; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n;; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n;; ============================================================================\n;; Using this Tutorial\n;; ============================================================================\n\n;; # Evaluating forms\n;;\n;; You can evaluate forms in this tutorial by putting your cursor at the end of\n;; the form and pressing \"Cmd-Enter\". The output will be displayed to the\n;; right of your cursor. You can dismiss the output view (if it's in your way)\n;; with \"Cmd-Shift-Enter\".\n;;\n;; Try evaluating this:\n\n(+ 1 2) ; <- put your cursor right after the closing ) and press Cmd-Enter\n\n;; ^ You can also put your cursor on the following line and press Cmd-Enter\n\n;; Ok, that was cool, but how about some data that's more complicated?\n{:some 10\n :other 20\n :list (range 10)} ; evaluate this, and you'll be able to interact with the result\n\n;; # Documentation + auto-complete\n;;\n;; If you click `range` in that code above, the documentation for the range\n;; function will appear in the bottom-right corner of this page. You can type\n;; into this document, and documentation + auto-complete suggestions will\n;; appear. Press Tab (and Shift-Tab) to cycle through the suggestions.\n;;\n;; Go ahead, put your cursor at the end of `map`, and see what other functions\n;; have `map` in the name.\n\nmap\n\n;; # The REPL\n;;\n;; The right hand pane is a REPL where you can type in clojurescript code and\n;; see the results. It will show you documentation + auto-complete suggestions\n;; as well.\n\n\n;; ============================================================================\n;; The Setup\n;; ============================================================================\n\n;; We've already evaluated this for you, so you're already in the tutorial.quil ns\n(ns tutorial.quil\n  (:require [quil.core :as q]))\n\n;; We start with a fairly simple setup function, no state, and empty update &\n;; draw functions so we can experiment at the REPL\n\n(defn setup []\n  (q/smooth)\n  (q/frame-rate 10)\n  (q/background 255)\n  {})\n\n(defn q-update [state]\n  state)\n\n(defn draw [state]\n  )\n\n;; In normal quil, this `makesketch` would be `q/defsketch`, but we're doing some\n;; magic so that it will work in this tutorial enviornment. The API is the same,\n;; although we automatically enable the `fun-mode` middleware for you.\n(makesketch example\n  :title \"My Sketch\"\n  :setup setup\n  :update q-update\n  :draw draw\n  :size [323 200])\n\n;; When you evaluate this (Cmd-Enter on the line below it), a new quil sketch\n;; will open. If you evaluate it again, the sketch will reload (setup will run\n;; again, etc.). If you change `example` to some other name, or create a new\n;; `(makesketch)` form with a different name, another sketch will open. The most\n;; recent sketch you've created will also be available to the REPL -- if you\n;; execute `q/rect` in the REPL or in this page, it will be evaluated on the most\n;; recently created sketch.\n\n\n;; ============================================================================\n;; Drawing\n;; ============================================================================\n;; Once you've made the sketch, we can start drawing on it.\n\n;; # Solids & fill\n\n(q/rect 20 20 200 200)\n\n;; You can change the fill\n(q/fill 200) ; one argument (0-255) means gray\n\n(q/rect 20 20 200 200) ; now evalute again, and see that the color has changed\n\n(q/fill 0 255 100) ; three arguments (0-255) mean red, green, blue\n\n(q/rect 20 20 200 200)\n\n(q/ellipse 100 100 60 30) ; unlike the rect, the ellipse is *centered* around the first two args\n\n;; # Lines & Stroke\n\n(q/line 0 0 200 100)\n\n(q/stroke 255 0 100) ; you can also pass one arg for gray\n(q/stroke-weight 20)\n\n(q/line 0 0 200 100) ;; now try that line ^ again\n\n;; You can clear the canvas at any time with this\n(q/background 255) ; 255 = white\n\n;; Now lets use a clojurescript loop to do something more fun\n(dorun\n  (for [angle (range 0 360 10)]\n    (let [x (q/cos (q/radians angle))\n          y (q/sin (q/radians angle))]\n      (q/stroke (/ angle 2))\n      (q/line 100 100 (+ 100 (* x 100)) (+ 100 (* y 100))))))\n\n;; ============================================================================\n;; Animating\n;; ============================================================================\n;; Here we only have to change the draw function, and the\n;; sketch automatically updates to show the changes.\n\n(defn draw [state]\n  (q/stroke (q/random 255))\n  ;; (q/stroke (q/random 255) (q/random 255) (q/random 255))\n  (q/stroke-weight (q/random 10))\n  (q/fill (q/random 255))\n\n  (let [diam (q/random 100)\n        x    (q/random (q/width))\n        y    (q/random (q/height))]\n    (q/ellipse x y diam diam)))\n;; (put your cursor here and hit Cmd-Enter)\n\n;; Now try taking that `(dorun)` form from above and putting it in the draw\n;; function here; then you'll always have that wheel of lines on top of the\n;; circles that are drawn.\n\n;; There's a `q/stroke` call in that draw function that's commented out --\n;; remove the `;;' to make your sketch more colorful.\n;; Can you make the fill colorful as well?\n\n\n;; TODO more to come :)\n  ";
